"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stagewise";
exports.ids = ["vendor-chunks/@stagewise"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stagewise/toolbar-next/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@stagewise/toolbar-next/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StagewiseToolbar: () => (/* binding */ StagewiseToolbar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dynamic */ \"(ssr)/./node_modules/next/dist/api/app-dynamic.js\");\n/* __next_internal_client_entry_do_not_use__ StagewiseToolbar auto */ \n\nvar jsxRuntime = {\n    exports: {}\n};\nvar reactJsxRuntime_production = {};\n/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredReactJsxRuntime_production;\nfunction requireReactJsxRuntime_production() {\n    if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;\n    hasRequiredReactJsxRuntime_production = 1;\n    var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n    function jsxProd(type, config, maybeKey) {\n        var key = null;\n        void 0 !== maybeKey && (key = \"\" + maybeKey);\n        void 0 !== config.key && (key = \"\" + config.key);\n        if (\"key\" in config) {\n            maybeKey = {};\n            for(var propName in config)\"key\" !== propName && (maybeKey[propName] = config[propName]);\n        } else maybeKey = config;\n        config = maybeKey.ref;\n        return {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type,\n            key,\n            ref: void 0 !== config ? config : null,\n            props: maybeKey\n        };\n    }\n    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;\n    reactJsxRuntime_production.jsx = jsxProd;\n    reactJsxRuntime_production.jsxs = jsxProd;\n    return reactJsxRuntime_production;\n}\nvar reactJsxRuntime_development = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredReactJsxRuntime_development;\nfunction requireReactJsxRuntime_development() {\n    if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;\n    hasRequiredReactJsxRuntime_development = 1;\n     true && function() {\n        function getComponentNameFromType(type) {\n            if (null == type) return null;\n            if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n            if (\"string\" === typeof type) return type;\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_ACTIVITY_TYPE:\n                    return \"Activity\";\n            }\n            if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_CONTEXT_TYPE:\n                    return (type.displayName || \"Context\") + \".Provider\";\n                case REACT_CONSUMER_TYPE:\n                    return (type._context.displayName || \"Context\") + \".Consumer\";\n                case REACT_FORWARD_REF_TYPE:\n                    var innerType = type.render;\n                    type = type.displayName;\n                    type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                    return type;\n                case REACT_MEMO_TYPE:\n                    return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n                case REACT_LAZY_TYPE:\n                    innerType = type._payload;\n                    type = type._init;\n                    try {\n                        return getComponentNameFromType(type(innerType));\n                    } catch (x) {}\n            }\n            return null;\n        }\n        function testStringCoercion(value) {\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            try {\n                testStringCoercion(value);\n                var JSCompiler_inline_result = false;\n            } catch (e) {\n                JSCompiler_inline_result = true;\n            }\n            if (JSCompiler_inline_result) {\n                JSCompiler_inline_result = console;\n                var JSCompiler_temp_const = JSCompiler_inline_result.error;\n                var JSCompiler_inline_result$jscomp$0 = \"function\" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                JSCompiler_temp_const.call(JSCompiler_inline_result, \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", JSCompiler_inline_result$jscomp$0);\n                return testStringCoercion(value);\n            }\n        }\n        function getTaskName(type) {\n            if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n            if (\"object\" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return \"<...>\";\n            try {\n                var name = getComponentNameFromType(type);\n                return name ? \"<\" + name + \">\" : \"<...>\";\n            } catch (x) {\n                return \"<...>\";\n            }\n        }\n        function getOwner() {\n            var dispatcher = ReactSharedInternals.A;\n            return null === dispatcher ? null : dispatcher.getOwner();\n        }\n        function UnknownOwner() {\n            return Error(\"react-stack-top-frame\");\n        }\n        function hasValidKey(config) {\n            if (hasOwnProperty.call(config, \"key\")) {\n                var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                if (getter && getter.isReactWarning) return false;\n            }\n            return void 0 !== config.key;\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            function warnAboutAccessingKey() {\n                specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\", displayName));\n            }\n            warnAboutAccessingKey.isReactWarning = true;\n            Object.defineProperty(props, \"key\", {\n                get: warnAboutAccessingKey,\n                configurable: true\n            });\n        }\n        function elementRefGetterWithDeprecationWarning() {\n            var componentName = getComponentNameFromType(this.type);\n            didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(\"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"));\n            componentName = this.props.ref;\n            return void 0 !== componentName ? componentName : null;\n        }\n        function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {\n            self = props.ref;\n            type = {\n                $$typeof: REACT_ELEMENT_TYPE,\n                type,\n                key,\n                props,\n                _owner: owner\n            };\n            null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, \"ref\", {\n                enumerable: false,\n                get: elementRefGetterWithDeprecationWarning\n            }) : Object.defineProperty(type, \"ref\", {\n                enumerable: false,\n                value: null\n            });\n            type._store = {};\n            Object.defineProperty(type._store, \"validated\", {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: 0\n            });\n            Object.defineProperty(type, \"_debugInfo\", {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: null\n            });\n            Object.defineProperty(type, \"_debugStack\", {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: debugStack\n            });\n            Object.defineProperty(type, \"_debugTask\", {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: debugTask\n            });\n            Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n            return type;\n        }\n        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {\n            var children = config.children;\n            if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {\n                for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);\n                Object.freeze && Object.freeze(children);\n            } else console.error(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else validateChildKeys(children);\n            if (hasOwnProperty.call(config, \"key\")) {\n                children = getComponentNameFromType(type);\n                var keys = Object.keys(config).filter(function(k) {\n                    return \"key\" !== k;\n                });\n                isStaticChildren = 0 < keys.length ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\", console.error('A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);\n            }\n            children = null;\n            void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = \"\" + maybeKey);\n            hasValidKey(config) && (checkKeyStringCoercion(config.key), children = \"\" + config.key);\n            if (\"key\" in config) {\n                maybeKey = {};\n                for(var propName in config)\"key\" !== propName && (maybeKey[propName] = config[propName]);\n            } else maybeKey = config;\n            children && defineKeyPropWarningGetter(maybeKey, \"function\" === typeof type ? type.displayName || type.name || \"Unknown\" : type);\n            return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);\n        }\n        function validateChildKeys(node) {\n            \"object\" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);\n        }\n        var React = react__WEBPACK_IMPORTED_MODULE_0__, REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {\n            return null;\n        };\n        React = {\n            \"react-stack-bottom-frame\": function(callStackForError) {\n                return callStackForError();\n            }\n        };\n        var specialPropKeyWarningShown;\n        var didWarnAboutElementRef = {};\n        var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(React, UnknownOwner)();\n        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n        var didWarnAboutKeySpread = {};\n        reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;\n        reactJsxRuntime_development.jsx = function(type, config, maybeKey, source, self) {\n            var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n            return jsxDEVImpl(type, config, maybeKey, false, source, self, trackActualOwner ? Error(\"react-stack-top-frame\") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);\n        };\n        reactJsxRuntime_development.jsxs = function(type, config, maybeKey, source, self) {\n            var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n            return jsxDEVImpl(type, config, maybeKey, true, source, self, trackActualOwner ? Error(\"react-stack-top-frame\") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);\n        };\n    }();\n    return reactJsxRuntime_development;\n}\nvar hasRequiredJsxRuntime;\nfunction requireJsxRuntime() {\n    if (hasRequiredJsxRuntime) return jsxRuntime.exports;\n    hasRequiredJsxRuntime = 1;\n    if (false) {} else {\n        jsxRuntime.exports = requireReactJsxRuntime_development();\n    }\n    return jsxRuntime.exports;\n}\nvar jsxRuntimeExports = requireJsxRuntime();\nconst DynamicToolbar = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(async ()=>{\n    typeof require.resolveWeak !== \"undefined\" && require.resolveWeak(\"@stagewise/toolbar-react\");\n}, {\n    loadableGenerated: {\n        modules: [\n            \"../node_modules/@stagewise/toolbar-next/dist/index.js -> \" + \"@stagewise/toolbar-react\"\n        ]\n    },\n    ssr: false\n});\nconst StagewiseToolbar = ({ config, enabled = \"development\" === \"development\" })=>{\n    if (!enabled) {\n        return null;\n    }\n    return /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicToolbar, {\n        config,\n        enabled\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0YWdld2lzZS90b29sYmFyLW5leHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7c0VBQytCO0FBQ0k7QUFDbkMsSUFBSUUsYUFBYTtJQUFFQyxTQUFTLENBQUM7QUFBRTtBQUMvQixJQUFJQyw2QkFBNkIsQ0FBQztBQUNsQzs7Ozs7Ozs7Q0FRQyxHQUNELElBQUlDO0FBQ0osU0FBU0M7SUFDUCxJQUFJRCx1Q0FBdUMsT0FBT0Q7SUFDbERDLHdDQUF3QztJQUN4QyxJQUFJRSxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQywrQkFBK0JDLHNCQUFzQkYsT0FBT0MsR0FBRyxDQUFDO0lBQ3BHLFNBQVNFLFFBQVFDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxRQUFRO1FBQ3JDLElBQUlDLE1BQU07UUFDVixLQUFLLE1BQU1ELFlBQWFDLENBQUFBLE1BQU0sS0FBS0QsUUFBTztRQUMxQyxLQUFLLE1BQU1ELE9BQU9FLEdBQUcsSUFBS0EsQ0FBQUEsTUFBTSxLQUFLRixPQUFPRSxHQUFHO1FBQy9DLElBQUksU0FBU0YsUUFBUTtZQUNuQkMsV0FBVyxDQUFDO1lBQ1osSUFBSyxJQUFJRSxZQUFZSCxPQUNuQixVQUFVRyxZQUFhRixDQUFBQSxRQUFRLENBQUNFLFNBQVMsR0FBR0gsTUFBTSxDQUFDRyxTQUFTO1FBQ2hFLE9BQU9GLFdBQVdEO1FBQ2xCQSxTQUFTQyxTQUFTRyxHQUFHO1FBQ3JCLE9BQU87WUFDTEMsVUFBVVg7WUFDVks7WUFDQUc7WUFDQUUsS0FBSyxLQUFLLE1BQU1KLFNBQVNBLFNBQVM7WUFDbENNLE9BQU9MO1FBQ1Q7SUFDRjtJQUNBViwyQkFBMkJnQixRQUFRLEdBQUdWO0lBQ3RDTiwyQkFBMkJpQixHQUFHLEdBQUdWO0lBQ2pDUCwyQkFBMkJrQixJQUFJLEdBQUdYO0lBQ2xDLE9BQU9QO0FBQ1Q7QUFDQSxJQUFJbUIsOEJBQThCLENBQUM7QUFDbkM7Ozs7Ozs7O0NBUUMsR0FDRCxJQUFJQztBQUNKLFNB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S0FBcUMsRUFBRSxFQUUxQyxNQUFNO1FBQ0x0SCxXQUFXQyxPQUFPLEdBQUdzQjtJQUN2QjtJQUNBLE9BQU92QixXQUFXQyxPQUFPO0FBQzNCO0FBQ0EsSUFBSXNILG9CQUFvQkY7QUFDeEIsTUFBTUcsaUJBQWlCekgsd0RBQU9BOzs7Ozs7OztJQUkxQjBILEtBQUs7O0FBRVQsTUFBTUMsbUJBQW1CLENBQUMsRUFBRS9HLE1BQU0sRUFBRWdILFVBQVVMLGtCQUF5QixhQUFhLEVBQUU7SUFDcEYsSUFBSSxDQUFDSyxTQUFTO1FBQ1osT0FBTztJQUNUO0lBQ0EsT0FBTyxhQUFhLEdBQUdKLGtCQUFrQnBHLEdBQUcsQ0FBQ3FHLGdCQUFnQjtRQUFFN0c7UUFBUWdIO0lBQVE7QUFDakY7QUFHRSIsInNvdXJjZXMiOlsiL2hvbWUvdGovZGV2L3dlYi9zYW0tam95bmVyLXBob3RvZ3JhcGh5L25vZGVfbW9kdWxlcy9Ac3RhZ2V3aXNlL3Rvb2xiYXItbmV4dC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgZHluYW1pYyBmcm9tIFwibmV4dC9keW5hbWljXCI7XG52YXIganN4UnVudGltZSA9IHsgZXhwb3J0czoge30gfTtcbnZhciByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uO1xuZnVuY3Rpb24gcmVxdWlyZVJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uKCkge1xuICBpZiAoaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbikgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uO1xuICBoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uID0gMTtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSwgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgZnVuY3Rpb24ganN4UHJvZCh0eXBlLCBjb25maWcsIG1heWJlS2V5KSB7XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdm9pZCAwICE9PSBtYXliZUtleSAmJiAoa2V5ID0gXCJcIiArIG1heWJlS2V5KTtcbiAgICB2b2lkIDAgIT09IGNvbmZpZy5rZXkgJiYgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KTtcbiAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgY29uZmlnID0gbWF5YmVLZXkucmVmO1xuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgdHlwZSxcbiAgICAgIGtleSxcbiAgICAgIHJlZjogdm9pZCAwICE9PSBjb25maWcgPyBjb25maWcgOiBudWxsLFxuICAgICAgcHJvcHM6IG1heWJlS2V5XG4gICAgfTtcbiAgfVxuICByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbi5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uLmpzeCA9IGpzeFByb2Q7XG4gIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uLmpzeHMgPSBqc3hQcm9kO1xuICByZXR1cm4gcmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb247XG59XG52YXIgcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50ID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcbmZ1bmN0aW9uIHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCkgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcbiAgaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQgPSAxO1xuICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID8gbnVsbCA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiYgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKSwgdHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fCAodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiLCB0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCwgbnVsbCAhPT0gaW5uZXJUeXBlID8gaW5uZXJUeXBlIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSlcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHwgKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZSwgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fCAoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9IHRydWUsIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMsIGRlYnVnU3RhY2ssIGRlYnVnVGFzaykge1xuICAgICAgc2VsZiA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgIH0pIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwodHlwZSwgY29uZmlnLCBtYXliZUtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmLCBkZWJ1Z1N0YWNrLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKGlzU3RhdGljQ2hpbGRyZW4gPSAwOyBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoOyBpc1N0YXRpY0NoaWxkcmVuKyspXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwIDwga2V5cy5sZW5ndGggPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dIHx8IChrZXlzID0gMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiwgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAga2V5cyxcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICApLCBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9IHRydWUpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJiAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSksIGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiYgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIiA6IHR5cGVcbiAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2VsZixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlICYmIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJiBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUkJDAsIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSwgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIHZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLCBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgUkVBQ1RfQUNUSVZJVFlfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5hY3Rpdml0eVwiKSwgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLCBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2sgPyBjb25zb2xlLmNyZWF0ZVRhc2sgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVhY3QgPSB7XG4gICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbihjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3RbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudC5qc3ggPSBmdW5jdGlvbih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID0gMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIikgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgICByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQuanN4cyA9IGZ1bmN0aW9uKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPSAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIHRydWUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0oKTtcbiAgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcbn1cbnZhciBoYXNSZXF1aXJlZEpzeFJ1bnRpbWU7XG5mdW5jdGlvbiByZXF1aXJlSnN4UnVudGltZSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkSnN4UnVudGltZSkgcmV0dXJuIGpzeFJ1bnRpbWUuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRKc3hSdW50aW1lID0gMTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGpzeFJ1bnRpbWUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGpzeFJ1bnRpbWUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQoKTtcbiAgfVxuICByZXR1cm4ganN4UnVudGltZS5leHBvcnRzO1xufVxudmFyIGpzeFJ1bnRpbWVFeHBvcnRzID0gcmVxdWlyZUpzeFJ1bnRpbWUoKTtcbmNvbnN0IER5bmFtaWNUb29sYmFyID0gZHluYW1pYyhcbiAgKCkgPT4gaW1wb3J0KFwiQHN0YWdld2lzZS90b29sYmFyLXJlYWN0XCIpLnRoZW4oKG1vZCkgPT4gKHtcbiAgICBkZWZhdWx0OiBtb2QuU3RhZ2V3aXNlVG9vbGJhclxuICB9KSksXG4gIHsgc3NyOiBmYWxzZSB9XG4pO1xuY29uc3QgU3RhZ2V3aXNlVG9vbGJhciA9ICh7IGNvbmZpZywgZW5hYmxlZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgfSkgPT4ge1xuICBpZiAoIWVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChEeW5hbWljVG9vbGJhciwgeyBjb25maWcsIGVuYWJsZWQgfSk7XG59O1xuZXhwb3J0IHtcbiAgU3RhZ2V3aXNlVG9vbGJhclxufTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlJCQwIiwiZHluYW1pYyIsImpzeFJ1bnRpbWUiLCJleHBvcnRzIiwicmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb24iLCJoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uIiwicmVxdWlyZVJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsImpzeFByb2QiLCJ0eXBlIiwiY29uZmlnIiwibWF5YmVLZXkiLCJrZXkiLCJwcm9wTmFtZSIsInJlZiIsIiQkdHlwZW9mIiwicHJvcHMiLCJGcmFnbWVudCIsImpzeCIsImpzeHMiLCJyZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQiLCJoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCIsInJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfQUNUSVZJVFlfVFlQRSIsInRhZyIsImNvbnNvbGUiLCJlcnJvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQ09OU1VNRVJfVFlQRSIsIl9jb250ZXh0IiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsImlubmVyVHlwZSIsInJlbmRlciIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIl9wYXlsb2FkIiwiX2luaXQiLCJ4IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwidmFsdWUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IiwiZSIsIkpTQ29tcGlsZXJfdGVtcF9jb25zdCIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJjYWxsIiwiZ2V0VGFza05hbWUiLCJnZXRPd25lciIsImRpc3BhdGNoZXIiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIkEiLCJVbmtub3duT3duZXIiLCJFcnJvciIsImhhc1ZhbGlkS2V5IiwiaGFzT3duUHJvcGVydHkiLCJnZXR0ZXIiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJpc1JlYWN0V2FybmluZyIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5Iiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nIiwiY29tcG9uZW50TmFtZSIsImRpZFdhcm5BYm91dEVsZW1lbnRSZWYiLCJSZWFjdEVsZW1lbnQiLCJzZWxmIiwic291cmNlIiwib3duZXIiLCJkZWJ1Z1N0YWNrIiwiZGVidWdUYXNrIiwiX293bmVyIiwiZW51bWVyYWJsZSIsIl9zdG9yZSIsIndyaXRhYmxlIiwiZnJlZXplIiwianN4REVWSW1wbCIsImlzU3RhdGljQ2hpbGRyZW4iLCJjaGlsZHJlbiIsImlzQXJyYXlJbXBsIiwibGVuZ3RoIiwidmFsaWRhdGVDaGlsZEtleXMiLCJrZXlzIiwiZmlsdGVyIiwiayIsImpvaW4iLCJkaWRXYXJuQWJvdXRLZXlTcHJlYWQiLCJub2RlIiwidmFsaWRhdGVkIiwiUmVhY3QiLCJfX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJwcm90b3R5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJjcmVhdGVUYXNrIiwiY2FsbFN0YWNrRm9yRXJyb3IiLCJ1bmtub3duT3duZXJEZWJ1Z1N0YWNrIiwiYmluZCIsInVua25vd25Pd25lckRlYnVnVGFzayIsInRyYWNrQWN0dWFsT3duZXIiLCJyZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcyIsImhhc1JlcXVpcmVkSnN4UnVudGltZSIsInJlcXVpcmVKc3hSdW50aW1lIiwicHJvY2VzcyIsImpzeFJ1bnRpbWVFeHBvcnRzIiwiRHluYW1pY1Rvb2xiYXIiLCJzc3IiLCJTdGFnZXdpc2VUb29sYmFyIiwiZW5hYmxlZCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stagewise/toolbar-next/dist/index.js\n");

/***/ })

};
;